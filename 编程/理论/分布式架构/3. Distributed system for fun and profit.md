# 1. Distributed systems at a high level
There are two basic tasks that any computer system needs to accomplish:
- storage and
- computation
> 任何计算机系统都需要完成两项基本任务：存储和计算。

Distributed programming is the art of solving the same problem that you can solve on a single computer using multiple computers - usually, because the problem no longer fits on a single computer.
> 分布式编程是用多台计算机解决在单台计算机上可以解决的同一问题的艺术--通常是因为该问题不再适合在单台计算机上解决。

However, as problem sizes increase you will reach a point where either the hardware upgrade that allows you to solve the problem on a single node does not exist, or becomes cost-prohibitive. At that point, I welcome you to the world of distributed systems.
> 但是，随着问题规模的增大，你将会遇到这样的情况：要么无法升级硬件，让你在单个节点上解决问题，要么成本过高。这时，我欢迎你来到分布式系统的世界。

It is a current reality that the best value is in mid-range, commodity hardware - as long as the maintenance costs can be kept down through fault-tolerant software.
> 目前的现实情况是，只要能通过容错软件降低维护成本，中端商品硬件的价值最高。

Ideally, adding a new machine would increase the performance and capacity of the system linearly. But of course this is not possible, because there is some overhead that arises due to having separate computers. Data needs to be copied around, computation tasks have to be coordinated and so on. This is why it's worthwhile to study distributed algorithms - they provide efficient solutions to specific problems, as well as guidance about what is possible, what the minimum cost of a correct implementation is, and what is impossible.
> 在理想情况下，增加一台新机器可以线性地提高系统的性能和容量。但这当然是不可能的，因为拥有独立的计算机会产生一些开销。数据需要复制，计算任务需要协调等等。这就是为什么值得研究分布式算法的原因--它们为特定问题提供了高效的解决方案，并指导我们了解哪些是可能的，正确实现的最低成本是多少，以及哪些是不可能的。

## What we want to achieve: Scalability and other good things
[Scalability](http://en.wikipedia.org/wiki/Scalability)：is the ability of a system, network, or process, to handle a growing amount of work in a capable manner or its ability to be enlarged to accommodate that growth.
> 可扩展性：是指一个系统、网络或流程能够以适当的方式处理不断增长的工作量，或能够扩大以适应这种增长的能力。

- Size scalability: adding more nodes should make the system linearly faster; growing the dataset should not increase latency
- Geographic scalability: it should be possible to use multiple data centers to reduce the time it takes to respond to user queries, while dealing with cross-data center latency in some sensible manner.
- Administrative scalability: adding more nodes should not increase the administrative costs of the system (e.g. the administrators-to-machines ratio).
> 
	规模可扩展性：增加节点应使系统的速度呈线性增长；数据集的增长不应增加延迟
	地理可扩展性：应该可以使用多个数据中心来减少响应用户查询所需的时间，同时以某种合理的方式处理跨数据中心的延迟。
	管理可扩展性：增加节点不应增加系统的管理成本（如管理员与机器之比）。

A scalable system is one that continues to meet the needs of its users as scale increases. There are two particularly relevant aspects - performance and availability - which can be measured in various ways.
>可扩展系统是指随着规模的扩大，仍能满足用户需求的系统。有两个特别相关的方面--性能和可用性--可以通过各种方式来衡量。

### Performance (and latency)
[Performance](http://en.wikipedia.org/wiki/Computer_performance): is characterized by the amount of useful work accomplished by a computer system compared to the time and resources used.
> 性能：是指计算机系统完成的有用工作与所用时间和资源的比较。

Depending on the context, this may involve achieving one or more of the following:
- Short response time/low latency for a given piece of work
- High throughput (rate of processing work)
- Low utilization of computing resource(s)
> 根据具体情况，这可能涉及实现以下一个或多个目标：
	特定工作的响应时间短/延迟低
	高吞吐量（处理工作的速度）
	计算资源利用率低

There are tradeoffs involved in optimizing for any of these outcomes. For example, a system may achieve a higher throughput by processing larger batches of work thereby reducing operation overhead. The tradeoff would be longer response times for individual pieces of work due to batching.
> 在对上述任何结果进行优化时，都需要权衡利弊。例如，系统可以通过处理更大批量的工作来获得更高的吞吐量，从而减少运行开销。但这样做的代价是，由于批量处理，单个工作的响应时间会更长。

Latency: The state of being latent; delay, a period between the initiation of something and the occurrence.
> 延迟：潜伏状态；延迟，某事开始和发生之间的一段时间。

Let's assume for a moment that our distributed system does just one high-level task: given a query, it takes all of the data in the system and calculates a single result. In other words, think of a distributed system as a data store with the ability to run a single deterministic computation (function) over its current content:
`result = query(all data in the system)`
> 让我们假设一下，我们的分布式系统只完成一项高级任务：给定一个查询，它获取系统中的所有数据并计算出一个结果。换句话说，可以把分布式系统看作是一个数据存储库，能够对其当前内容进行单次确定性计算（函数）：
	结果 = 查询（系统中的所有数据）

Then, what matters for latency is not the amount of old data, but rather the speed at which new data "takes effect" in the system. For example, latency could be measured in terms of how long it takes for a write to become visible to readers.
> 因此，对延迟而言，重要的不是旧数据的数量，而是新数据在系统中 "生效 "的速度。例如，延迟可以用写入到读者可见所需的时间来衡量。

In a distributed system, there is a minimum latency that cannot be overcome: the speed of light limits how fast information can travel, and hardware components have a minimum latency cost incurred per operation (think RAM and hard drives but also CPUs).
> 在分布式系统中，有一个无法逾越的最低延迟时间：光速限制了信息的传播速度，而硬件组件每次操作都会产生最低延迟成本（例如内存和硬盘，但也包括 CPU）。

How much that minimum latency impacts your queries depends on the nature of those queries and the physical distance the information needs to travel.
> 最小延迟对查询的影响程度取决于查询的性质和信息需要传输的物理距离。

### Availability (and fault tolerance)
[Availability](http://en.wikipedia.org/wiki/High_availability): the proportion of time a system is in a functioning condition. If a user cannot access the system, it is said to be unavailable.
> 可用性：系统处于正常运行状态的时间比例。如果用户无法访问系统，则称系统不可用。

Distributed systems allow us to achieve desirable characteristics that would be hard to accomplish on a single system. For example, a single machine cannot tolerate any failures since it either fails or doesn't.
> 分布式系统使我们能够实现单个系统难以实现的理想特性。例如，单台机器不能容忍任何故障，因为它要么故障，要么不故障。

Systems that have no redundancy can only be as available as their underlying components. Systems built with redundancy can be tolerant of partial failures and thus be more available. It is worth noting that "redundant" can mean different things depending on what you look at - components, servers, datacenters and so on.
> 没有冗余的系统只能像其基础组件一样可用。有冗余的系统可以承受部分故障，因此可用性更高。值得注意的是，"冗余 "可以有不同的含义，这取决于你关注的是什么--组件、服务器、数据中心等。

Formulaically, availability is: `Availability = uptime / (uptime + downtime)`.
> 按公式计算，可用性为可用性 = 正常运行时间/（正常运行时间 + 停机时间）。

Availability from a technical perspective is mostly about being fault tolerant. Because the probability of a failure occurring increases with the number of components, the system should be able to compensate so as to not become less reliable as the number of components increases.
> 从技术角度看，可用性主要是指容错性。由于发生故障的概率会随着组件数量的增加而增加，因此系统应该能够进行补偿，从而不会随着组件数量的增加而降低可靠性。

Availability is in some sense a much wider concept than uptime, since the availability of a service can also be affected by, say, a network outage or the company owning the service going out of business (which would be a factor which is not really relevant to fault tolerance but would still influence the availability of the system). But without knowing every single specific aspect of the system, the best we can do is design for fault tolerance.
> 在某种意义上，可用性是一个比正常运行时间更宽泛的概念，因为服务的可用性也会受到影响，例如网络中断或拥有服务的公司倒闭（这是一个与容错无关的因素，但仍会影响系统的可用性）。但在不了解系统每个具体方面的情况下，我们能做的就是设计容错。

Fault tolerance: ability of a system to behave in a well-defined manner once faults occur.
> 容错：系统在故障发生时以明确定义的方式运行的能力。

Fault tolerance boils down to this: define what faults you expect and then design a system or an algorithm that is tolerant of them. You can't tolerate faults you haven't considered.
> 容错归根结底就是：确定你所期望的故障，然后设计出能够容错的系统或算法。你不可能容忍你没有考虑到的故障。

## What prevents us from achieving good things?
Distributed systems are constrained by two physical factors:
- the number of nodes (which increases with the required storage and computation capacity)
- the distance between nodes (information travels, at best, at the speed of light)
> 分布式系统受到两个物理因素的制约：
	节点数量（随所需存储和计算能力的增加而增加）
	节点之间的距离（信息最多以光速传播）

Working within those constraints:
- an increase in the number of independent nodes increases the probability of failure in a system (reducing availability and increasing administrative costs)
- an increase in the number of independent nodes may increase the need for communication between nodes (reducing performance as scale increases)
- an increase in geographic distance increases the minimum latency for communication between distant nodes (reducing performance for certain operations)
> 在这些限制条件下开展工作：
	增加独立节点的数量会增加系统发生故障的概率（降低可用性并增加管理成本）
	独立节点数量的增加可能会增加节点之间的通信需求（随着规模的扩大而降低性能）
	地理距离的增加会增加远距离节点间通信的最小延迟（降低某些操作的性能）

Beyond these tendencies - which are a result of the physical constraints - is the world of system design options.
> 除了这些由物理限制之外，还有系统设计方案的限制。

Both performance and availability are defined by the external guarantees the system makes. On a high level, you can think of the guarantees as the SLA (service level agreement) for the system: if I write data, how quickly can I access it elsewhere? After the data is written, what guarantees do I have of durability? If I ask the system to run a computation, how quickly will it return results? When components fail, or are taken out of operation, what impact will this have on the system?
> 性能和可用性都是由系统的外部保证来定义的。从高层次上讲，可以将这些保证视为系统的 SLA（服务水平协议）：如果我写入数据，我在其他地方访问数据的速度有多快？数据写入后，我如何保证数据的持久性？如果我要求系统运行计算，它能多快返回结果？当组件发生故障或停止运行时，会对系统产生什么影响？

There is another criterion, which is not explicitly mentioned but implied: intelligibility. How understandable are the guarantees that are made? Of course, there are no simple metrics for what is intelligible.
> 还有一个标准没有明确提及，但隐含其中：可理解性。所做的保证有多容易理解？当然，什么是可理解性并没有简单的衡量标准。

## Abstractions and models
This is where abstractions and models come into play. Abstractions make things more manageable by removing real-world aspects that are not relevant to solving a problem. Models describe the key properties of a distributed system in a precise manner. I'll discuss many kinds of models in the next chapter, such as:
- System model (asynchronous / synchronous)
- Failure model (crash-fail, partitions, Byzantine)
- Consistency model (strong, eventual)
> 这就是抽象和模型发挥作用的地方。抽象可以去除现实世界中与解决问题无关的方面，从而使问题更易于管理。模型以精确的方式描述了分布式系统的关键属性。我将在下一章讨论多种模型，如
	系统模型（异步/同步）
	故障模型（崩溃-故障、分区、拜占庭）
	一致性模型（强一致性、最终一致性）

A good abstraction makes working with a system easier to understand, while capturing the factors that are relevant for a particular purpose.
> 一个好的抽象概念可以使系统的工作更容易理解，同时还能捕捉到与特定目的相关的因素。

## Design techniques: partition and replicate
The manner in which a data set is distributed between multiple nodes is very important. In order for any computation to happen, we need to locate the data and then act on it.
> 数据集在多个节点之间分布的方式非常重要。为了进行计算，我们需要找到数据，然后对其进行操作。

There are two basic techniques that can be applied to a data set. It can be split over multiple nodes (partitioning) to allow for more parallel processing. It can also be copied or cached on different nodes to reduce the distance between the client and the server and for greater fault tolerance (replication).
> 有两种基本技术可用于数据集。可以将数据分割到多个节点上（分区），以便进行更多并行处理。也可以在不同的节点上复制或缓存数据，以缩短客户端与服务器之间的距离，提高容错能力（复制）。

The picture below illustrates the difference between these two: partitioned data (A and B below) is divided into independent sets, while replicated data (C below) is copied to multiple locations.
> 下图说明了两者之间的区别：分区数据（下图中的 A 和 B）被划分为独立的数据集，而复制数据（下图中的 C）被复制到多个位置。
![[part-repl.png]]

This is the one-two punch for solving any problem where distributed computing plays a role. Of course, the trick is in picking the right technique for your concrete implementation; there are many algorithms that implement replication and partitioning, each with different limitations and advantages which need to be assessed against your design objectives.
> 这是解决任何涉及分布式计算问题的一记重拳。当然，诀窍在于为您的具体实现选择正确的技术；有许多实现复制和分区的算法，每种算法都有不同的局限性和优势，需要根据您的设计目标进行评估。

### Partitioning
Partitioning is dividing the dataset into smaller distinct independent sets; this is used to reduce the impact of dataset growth since each partition is a subset of the data.
- Partitioning improves performance by limiting the amount of data to be examined and by locating related data in the same partition
- Partitioning improves availability by allowing partitions to fail independently, increasing the number of nodes that need to fail before availability is sacrificed
> 分区是指将数据集划分为不同的独立小集；这用于减少数据集增长的影响，因为每个分区都是数据的一个子集。
	分区可以限制需要检查的数据量，并将相关数据定位在同一分区中，从而提高性能。
	分区允许分区独立发生故障，增加了在牺牲可用性之前需要发生故障的节点数量，从而提高了可用性

Partitioning is also very much application-specific, so it is hard to say much about it without knowing the specifics. That's why the focus is on replication in most texts, including this one.
> 分区在很大程度上也与具体应用有关，因此，在不了解具体情况的情况下，很难对其进行深入探讨。这就是为什么大多数文章（包括本文章）的重点都放在复制上。

### Replication
Replication is making copies of the same data on multiple machines; this allows more servers to take part in the computation.
> 复制是指在多台机器上复制相同的数据；这样可以让更多服务器参与计算。

Replication - copying or reproducing something - is the primary way in which we can fight latency.
- Replication improves performance by making additional computing power and bandwidth applicable to a new copy of the data
- Replication improves availability by creating additional copies of the data, increasing the number of nodes that need to fail before availability is sacrificed
> 复制 - 复制或复制某些东西 - 是我们对抗延迟的主要方式。
	复制通过使额外的计算能力和带宽适用于新的数据拷贝来提高性能
	复制通过创建额外的数据副本来提高可用性，从而增加在牺牲可用性之前需要失败的节点数

Replication is about providing extra bandwidth, and caching where it counts. It is also about maintaining consistency in some way according to some consistency model.
> 复制是为了提供额外的带宽，并在重要的地方进行缓存。此外，复制还需要根据某种一致性模型，以某种方式保持一致性。

Replication allows us to achieve scalability, performance and fault tolerance. Afraid of loss of availability or reduced performance? Replicate the data to avoid a bottleneck or single point of failure. Slow computation? Replicate the computation on multiple systems. Slow I/O? Replicate the data to a local cache to reduce latency or onto multiple machines to increase throughput.
> 复制使我们能够实现可扩展性、性能和容错。害怕丧失可用性或降低性能？复制数据以避免瓶颈或单点故障。计算速度慢？在多个系统上复制计算。I/O 速度慢？将数据复制到本地缓存以减少延迟，或复制到多台机器上以提高吞吐量。

Replication is also the source of many of the problems, since there are now independent copies of the data that has to be kept in sync on multiple machines - this means ensuring that the replication follows a consistency model.
> 复制也是许多问题的根源，因为现在有独立的数据副本，必须在多台机器上保持同步--这意味着要确保复制遵循一致性模型。

The choice of a consistency model is crucial: a good consistency model provides clean semantics for programmers (in other words, the properties it guarantees are easy to reason about) and meets business/design goals such as high availability or strong consistency.
> 一致性模型的选择至关重要：一个好的一致性模型能为程序员提供简洁的语义（换句话说，它所保证的属性易于推理），并能满足业务/设计目标，如高可用性或强一致性。

Only one consistency model for replication - strong consistency - allows you to program as-if the underlying data was not replicated. Other consistency models expose some internals of the replication to the programmer. However, weaker consistency models can provide lower latency and higher availability - and are not necessarily harder to understand, just different.
> 只有一种复制的一致性模型--强一致性--允许你在编程时假设底层数据没有被复制。其他一致性模型会向程序员暴露复制的一些内部信息。然而，较弱的一致性模型可以提供更低的延迟和更高的可用性，而且并不一定更难理解，只是不同而已。

# 2. Up and down the level of abstraction

# 锁
## 悲观锁（写操作场景）
先获取锁，再操作

## 乐观锁（读操作场景）
先操作，再判断锁情况

### 版本号机制
1. 读取数据（版本号）
2. 操作
3. 更新数据（比较版本号）

### CAS
CAS是依赖于操作系统底层的原子操作，它会对指定值进行比较&替换：`cas(key, oldValue, newValue)`
- 如果`key`对应的值等于`oldValue`，会将该值更新为`newValue`，并返回`true`。
- 如果`key`对应的值不等于`oldValue`，则返回`false`。

CAS操作失败后，该线程可以再次尝试（自旋），也可以放弃操作，取决于具体实现。

CAS存在`ABA`问题：在获取`oldValue`到`cas()`执行的时间范围内，`value`可能被多次修改，但最终值和初始值相等。解决办法是`value`中添加版本号或时间戳信息。

# 线程池ThreadPoolExecutor
核心参数：
- `corePoolSize`：核心线程数
- `maximumPoolSize`：最大线程数
- `workQueue`：任务缓存队列
- `handler`：饱和策略
- `keepAliverTime`：核心外线程的最大等待时间，超过该时间后仍然没有被使用，会被销毁

饱和策略：
- `ThreadPoolExecutor.AbortPolicy`（默认）：抛异常
- `ThreadPoolExecutor.CallerRunsPolicy`（推荐）：由调用线程执行任务
- `ThreadPoolExecutor.DiscardPolicy`：丢弃当前任务
- `ThreadPoolExecutor.DiscardOldestPolicy`：丢弃最早等待的任务

原理：
1. 提交任务
2. 判断核心线程数是否已满：
	1. 否：创建线程，执行
	2. 是：等待队列是否已满：
		1. 否：加入等待队列
		2. 是：最大线程数是否已满：
			1. 否：创建线程，执行
			2. 是：按饱和策略处理

线程池大小：
- CPU密集型任务（N+1）
- IO密集型任务（2N）

# AQS-AbstractQueuedSynchronizer
AQS为构建锁和同步器提供了一些通用功能的实现，通过实现AQS能够简单创建出各种类型的同步器：`ReentrantLock`、`Semaphore`等。



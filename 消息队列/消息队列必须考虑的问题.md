# 1 为什么使用消息队列？
> 消息队列：**异步**、**解耦**、**削峰**。

当别人问你为什么要使用消息队列时，其实就是问你消息队列有什么功能。

日常项目中，使用消息队列主要是为了使用它的以下核心功能：
- 异步：优化不必实时处理的耗时操作，提高系统处理性能。
- 解耦
- 削峰

当日常项目中遇到了这三个需求，都可以使用消息队列。我们使用消息队列，也主要是为了解决以上三个业务问题。

所以：消息队列 <==> 异步/解耦/削峰。

## 1.1 异步
> 消息队列异步处理：耗时操作&不要求实时处理

当某个业务场景需要经过多个步骤处理时，如果其中某个步骤的处理过程十分耗时，并且不要求实时完成，我们通常会考虑异步处理。

举个简单例子，某个业务需要经过3个步骤，`step1()`和`step2()`都耗时300ms，`step3()`耗时3ms，并且`step3()`依赖`step1()`的返回值。此时，我们可以考虑将`step1()`和`step2()`进行异步处理。：
```java
public void service() {
	Object res1 = step1();  // 300ms
	step2();  // 300ms
	step3(res1);  // 3ms
}
```

由于`step1()`会影响其他步骤的执行顺序，它和`step3()`有先后顺序，因此不能简单使用消息队列异步处理。

而`step2()`与其他步骤没有强烈顺序关系，如果该步骤不要求实时执行，则可以使用消息队列进行异步处理：
```java
public void service() {
	Object res1 = step1();  // 300ms
	sendMessageToStep2();  // 3ms
	step3(res1);  // 3ms
}
```

此时，该业务处理耗时由最初的`603ms`优化到了`306ms`，大大提高了系统的性能。

## 1.2 解耦
> 消息队列充当中间层，解决多个系统间的强耦合问题。

假设存在多个系统，其中系统A在业务处理过程中需要通知其他系统，可以使用强耦合的方式：
```java
public void notifyOtherSystem() {
	notifySystemB();
	notifySystemC();
	notifySystemD();
}
```

对于其他系统来说，它们需要各自定义接收通知的方法。对于系统A来说，它需要针对每一个接收通知的系统定义一个通知方法。在这个过程中，还会涉及到系统间的对接。有过相关经历的人都会知道，这个过程十分耗时耗力。

如果系统B不需要接收通知了，或者新增系统E需要接收通知。那么对于这些系统的维护人员来说，都是十分崩溃的过程。

对于这种业务场景，我们可以使用消息队列的发布订阅功能进行优化。

系统A可以定义统一的通知消息，发送到消息队列中：
```java
public void sendToMq() {
	// 发送统一格式的消息
}
```

其他系统如果需要接收通知，它可以主动监听。如果不需要接收通知，也可以主动断开监听。例如，系统E需要监听消息，它可以在自己系统中新增监听方法：
```java
public void listener(Object msg) {
	// 系统E针对通知的特殊处理
}
```

此时，消息队列作为中间层，将系统A和其他系统进行了解耦。每个其他系统都可以在单个系统的最小维度进行监听或取消监听消息，大大降低了繁琐的重复开发步骤。

## 1.3 削峰
> 大量请求延后处理。

